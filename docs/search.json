[
  {
    "objectID": "labs/lab2.html",
    "href": "labs/lab2.html",
    "title": "Lab 2: Data Manipulation and Visualization",
    "section": "",
    "text": "In Lab 1, we briefly introduced what packages are in R and one specific package tidyverse. If you wish to learn more about tidyverse, click here for more information. Lab 2 will focus on two packages that are included in tidyverse:\nBut first, remember to load the package.\n# install.packages(\"tidyverse\")     # install if needed\nlibrary(tidyverse)"
  },
  {
    "objectID": "labs/lab2.html#data-manipulation-using-dplyr",
    "href": "labs/lab2.html#data-manipulation-using-dplyr",
    "title": "Lab 2: Data Manipulation and Visualization",
    "section": "1 Data Manipulation using dplyr",
    "text": "1 Data Manipulation using dplyr\n\n1.1 What is a Tidy Data Set?\nTidy data is a standard way of mapping the meaning of a dataset to its structure. A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types. Three rules make a data tidy:\n\nEach variable must have its own column\nEach observation must have its own row\nEach value must have its own cell\n\n\n\n1.2 Create a Farm Business Data Set\n\n# farmers' info\nname &lt;- c(\"Henry\", \"Larry\", \"Alex\", \"Gaby\", \"Amy\", \"Ruby\")\nsex &lt;- c(\"male\", \"male\", \"male\", \"female\", \"female\", \"female\")\nage &lt;- c(43, 60, 25, 50, 28, 58)\n\n# types of farm\ntype &lt;- c(\"crop\", \"livestock\", \"urban\", \"dairy\", \"crop\", \"livestock\")\n\n# size of farm in acres\nsize &lt;- c(550, 800, 10, 600, 1000, 700)\n\n# net annual cash return from ag businesses, in $1000\nreturn &lt;- c(40, 90, 50, 90, 90, 95)\n\n# combine the variables together as a data frame\nfarm &lt;- data.frame(name, age, sex, type, size, return)\nfarm\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n\n\nAlex\n25\nmale\nurban\n10\n50\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n\n\n\n\n\n# glimpse the data set\nglimpse(farm)\n\nRows: 6\nColumns: 6\n$ name   &lt;chr&gt; \"Henry\", \"Larry\", \"Alex\", \"Gaby\", \"Amy\", \"Ruby\"\n$ age    &lt;dbl&gt; 43, 60, 25, 50, 28, 58\n$ sex    &lt;chr&gt; \"male\", \"male\", \"male\", \"female\", \"female\", \"female\"\n$ type   &lt;chr&gt; \"crop\", \"livestock\", \"urban\", \"dairy\", \"crop\", \"livestock\"\n$ size   &lt;dbl&gt; 550, 800, 10, 600, 1000, 700\n$ return &lt;dbl&gt; 40, 90, 50, 90, 90, 95\n\n\n\n\n1.3 Important Functions in dplyr\nThere are six important functions in dplyr are:\n\nselect(): pick variables by their names\nfilter(): pick observations by their values\narrange(): reorder the rows\nmutate(): create new variables with functions of existing variables\nsummarize(): collapse many values down to a single summary\ngroup_by(): groups data by one or more variables, allowing subsequent operations to be applied independently to each group\n\nCombining with the pipe operator %&gt;%, dplyr can make data manipulation simple and intuitive.\n\n\n\n\n\n\nTip\n\n\n\nYou can always type “?FUNCTION_NAME” in the Console pane to check the R Documentation for the function. Try ?select.\n\n\n\n1.3.1 select()\nselect() allows you to focus on the variables you’re interested in.\n\nselect(farm, c(type, size, return))     # select farm type, size and return\n\n\n\n\n\ntype\nsize\nreturn\n\n\n\n\ncrop\n550\n40\n\n\nlivestock\n800\n90\n\n\nurban\n10\n50\n\n\ndairy\n600\n90\n\n\ncrop\n1000\n90\n\n\nlivestock\n700\n95\n\n\n\n\n\nselect(farm, sex:size)      # select everything between sex and size\n\n\n\n\n\nsex\ntype\nsize\n\n\n\n\nmale\ncrop\n550\n\n\nmale\nlivestock\n800\n\n\nmale\nurban\n10\n\n\nfemale\ndairy\n600\n\n\nfemale\ncrop\n1000\n\n\nfemale\nlivestock\n700\n\n\n\n\n\nselect(farm, -name)     # select everything but names\n\n\n\n\n\nage\nsex\ntype\nsize\nreturn\n\n\n\n\n43\nmale\ncrop\n550\n40\n\n\n60\nmale\nlivestock\n800\n90\n\n\n25\nmale\nurban\n10\n50\n\n\n50\nfemale\ndairy\n600\n90\n\n\n28\nfemale\ncrop\n1000\n90\n\n\n58\nfemale\nlivestock\n700\n95\n\n\n\n\n\n\n\n\n1.3.2 filter()\nfilter() allows you to subset observations based on their values.\n\nfilter(farm, size &gt; 500)      # select farms with size &gt; 500\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n\n\n\n\n\nfilter(farm, size &gt; 500 & sex == \"female\")      # select farms with size &gt; 500 AND owned by female farmers\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n\n\n\n\n\n\n\n\n1.3.3 arrange()\narrange() orders the observations by one or more variables. Basically, it changes the order of rows.\n\narrange(farm, size)      # order the data set by farm size, by default, in ascending order\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nAlex\n25\nmale\nurban\n10\n50\n\n\nHenry\n43\nmale\ncrop\n550\n40\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n\n\n\n\n\narrange(farm, desc(size))      # change the ordering to descending\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n\n\nHenry\n43\nmale\ncrop\n550\n40\n\n\nAlex\n25\nmale\nurban\n10\n50\n\n\n\n\n\n\n\n\n1.3.4 mutate()\nmudate() modifies existing variables or adds new variables.\n\nmutate(farm, return = return * 1000)\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40000\n\n\nLarry\n60\nmale\nlivestock\n800\n90000\n\n\nAlex\n25\nmale\nurban\n10\n50000\n\n\nGaby\n50\nfemale\ndairy\n600\n90000\n\n\nAmy\n28\nfemale\ncrop\n1000\n90000\n\n\nRuby\n58\nfemale\nlivestock\n700\n95000\n\n\n\n\n\nmutate(farm, age.sq = age ^ 2)\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\nage.sq\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40\n1849\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n3600\n\n\nAlex\n25\nmale\nurban\n10\n50\n625\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n2500\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n784\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n3364\n\n\n\n\n\nmutate(farm, per.acre.return = return / size)\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\nper.acre.return\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40\n0.0727273\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n0.1125000\n\n\nAlex\n25\nmale\nurban\n10\n50\n5.0000000\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n0.1500000\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n0.0900000\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n0.1357143\n\n\n\n\n\n# Or, you can do all three in one step\nmutate(farm,\n  return = return * 1000, \n  age.sq = age ^ 2,\n  per.acre.return = return / size\n)\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\nage.sq\nper.acre.return\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40000\n1849\n72.72727\n\n\nLarry\n60\nmale\nlivestock\n800\n90000\n3600\n112.50000\n\n\nAlex\n25\nmale\nurban\n10\n50000\n625\n5000.00000\n\n\nGaby\n50\nfemale\ndairy\n600\n90000\n2500\n150.00000\n\n\nAmy\n28\nfemale\ncrop\n1000\n90000\n784\n90.00000\n\n\nRuby\n58\nfemale\nlivestock\n700\n95000\n3364\n135.71429\n\n\n\n\n\n# change the classes of variables\nglimpse(farm)      # view the data before changes\n\nRows: 6\nColumns: 6\n$ name   &lt;chr&gt; \"Henry\", \"Larry\", \"Alex\", \"Gaby\", \"Amy\", \"Ruby\"\n$ age    &lt;dbl&gt; 43, 60, 25, 50, 28, 58\n$ sex    &lt;chr&gt; \"male\", \"male\", \"male\", \"female\", \"female\", \"female\"\n$ type   &lt;chr&gt; \"crop\", \"livestock\", \"urban\", \"dairy\", \"crop\", \"livestock\"\n$ size   &lt;dbl&gt; 550, 800, 10, 600, 1000, 700\n$ return &lt;dbl&gt; 40, 90, 50, 90, 90, 95\n\nfarm2 &lt;- mutate(farm,\n                sex = as.factor(sex), \n                type = as.factor(type), \n                age = as.integer(age)\n         )\nglimpse(farm2)       # view the data after changes\n\nRows: 6\nColumns: 6\n$ name   &lt;chr&gt; \"Henry\", \"Larry\", \"Alex\", \"Gaby\", \"Amy\", \"Ruby\"\n$ age    &lt;int&gt; 43, 60, 25, 50, 28, 58\n$ sex    &lt;fct&gt; male, male, male, female, female, female\n$ type   &lt;fct&gt; crop, livestock, urban, dairy, crop, livestock\n$ size   &lt;dbl&gt; 550, 800, 10, 600, 1000, 700\n$ return &lt;dbl&gt; 40, 90, 50, 90, 90, 95\n\n\nThe function else() is often used in data manipulation, which assigns values to a variable based on whether a condition is satisfied.\n\nmutate(farm,\n       size2 = ifelse(size &gt; 600, \"big\", \"small\"),   \n       dummy_urban = ifelse(type == \"urban\", 1, 0)      # when testing for equality, use double ==\n)\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\nsize2\ndummy_urban\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40\nsmall\n0\n\n\nLarry\n60\nmale\nlivestock\n800\n90\nbig\n0\n\n\nAlex\n25\nmale\nurban\n10\n50\nsmall\n1\n\n\nGaby\n50\nfemale\ndairy\n600\n90\nsmall\n0\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\nbig\n0\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\nbig\n0\n\n\n\n\n\n\n\n\n1.3.5 summarize()\nsummarize() provides summary statistics, which always produce one single row if there are no grouping variables.\n\nsummarize(farm, tot.return = sum(return))\n\n\n\n\n\ntot.return\n\n\n\n\n455\n\n\n\n\n\nsummarize(farm, avg.return = mean(return))\n\n\n\n\n\navg.return\n\n\n\n\n75.83333\n\n\n\n\n\nsummarize(farm,\n          youngest = min(age),\n          oldest = max(age),\n          median = median(age),\n          cor.size.return = cor(size, return))\n\n\n\n\n\nyoungest\noldest\nmedian\ncor.size.return\n\n\n\n\n25\n60\n46.5\n0.6787267\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nIt is often the case that we wish to know the summary statstics by a certain groups, e.g. average return by gender. Therefore, the use of summarize() is usually combined with group_by() and the pipe operator %&gt;%.\n\n\n\n\n1.3.6 group_by() and %&gt;%\n\n1.3.6.1 group_by()\ngroup_by() groups data by named variables, the use of group_by() itself does not change any variables, but only re-order the data, simlar to arrange().\n\ngroup_by(farm, sex)\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n\n\nAlex\n25\nmale\nurban\n10\n50\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n\n\n\n\n\n\n\n\n1.3.6.2 %&gt;%\nHowever, then main purpose of group_by() is to group your data to perform following operation. To achieve this, you will also need the pipe operator %&gt;%. Functioning like pipes, %&gt;% uses the output of one function as the input to the next function.\nSuppose you wish to perform the steps below, based on the data farm:\n\ncalculate the return per acre, called “per.acre.return”\nkeep only the farms that are owned by farmers above 40 years old\ncreate a new data frame only contains: names and age of the farmers, and the return per acre\n\n\n### without %&gt;%\nfarm_wo_pipe1 &lt;- mutate(farm, per.acre.return = return / size)\nfarm_wo_pipe2 &lt;- filter(farm_wo_pipe1, age &gt; 40)\nfarm_wo_pipe3 &lt;- select(farm_wo_pipe2, c(name, age, per.acre.return))\nfarm_wo_pipe3\n\n\n\n\n\nname\nage\nper.acre.return\n\n\n\n\nHenry\n43\n0.0727273\n\n\nLarry\n60\n0.1125000\n\n\nGaby\n50\n0.1500000\n\n\nRuby\n58\n0.1357143\n\n\n\n\n\n### with %&gt;%\n\nfarm_w_pipe &lt;- farm %&gt;% mutate(per.acre.return = return / size) %&gt;%\n                        filter(age &gt; 40) %&gt;%\n                        select(name, age, per.acre.return)\nfarm_w_pipe\n\n\n\n\n\nname\nage\nper.acre.return\n\n\n\n\nHenry\n43\n0.0727273\n\n\nLarry\n60\n0.1125000\n\n\nGaby\n50\n0.1500000\n\n\nRuby\n58\n0.1357143\n\n\n\n\n\n\n\n\n1.3.6.3 Combining group_by() with %&gt;%\nNow, let’s calculate summary statistics by groups, using group_by() with %&gt;%.\n\nfarm %&gt;% group_by(sex) %&gt;% summarize(num.farmer = n(),\n                                     youngest = min(age),\n                                     oldest = max(age),  \n                                     \n                                     tot.return = sum(return),\n                                     avg.return = mean(return),\n                                     avg.per.acre.return = mean(return/size),\n                                     avg.size = mean(size))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsex\nnum.farmer\nyoungest\noldest\ntot.return\navg.return\navg.per.acre.return\navg.size\n\n\n\n\nfemale\n3\n28\n58\n275\n91.66667\n0.1252381\n766.6667\n\n\nmale\n3\n25\n60\n180\n60.00000\n1.7284091\n453.3333\n\n\n\n\n\n\n\n\n\n1.3.7 Other Functions/Verbs\n\n1.3.7.1 slice() and Its Variants\nYou can use slice() to select rows by position, or it variants\n\nslice_head() and slice_tail(): to select first/last rows\nslice_min() and slice_max(): to select rows with minimum/maximum values\nslice_sample(): to select random samples\n\n\nfarm\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n\n\nAlex\n25\nmale\nurban\n10\n50\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n\n\n\n\n\nfarm %&gt;% slice(3)     # pick the observation in row 3\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nAlex\n25\nmale\nurban\n10\n50\n\n\n\n\n\nfarm %&gt;% slice(1:3)     # pick observations from row 1 through row 3\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n\n\nAlex\n25\nmale\nurban\n10\n50\n\n\n\n\n\nfarm %&gt;% slice_head(n = 3)      # pick first 3 rows, slice_tail would pick the last 3 rows\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nHenry\n43\nmale\ncrop\n550\n40\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n\n\nAlex\n25\nmale\nurban\n10\n50\n\n\n\n\n\nfarm %&gt;% slice_min(age, n = 3)      # pick 3 rows with the youngest ages, slice_max would pick 3 rows with the largest ages\n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nAlex\n25\nmale\nurban\n10\n50\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n\n\nHenry\n43\nmale\ncrop\n550\n40\n\n\n\n\n\nfarm %&gt;% slice_sample(n = 3)      # randomly pick 3 observations \n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n\n\nAmy\n28\nfemale\ncrop\n1000\n90\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n\n\n\n\n\nfarm %&gt;% slice_sample(prop = 0.5)     # randomly pick 50% of the data \n\n\n\n\n\nname\nage\nsex\ntype\nsize\nreturn\n\n\n\n\nRuby\n58\nfemale\nlivestock\n700\n95\n\n\nGaby\n50\nfemale\ndairy\n600\n90\n\n\nLarry\n60\nmale\nlivestock\n800\n90\n\n\n\n\n\n\n\n\n1.3.7.2 count()\ncount() counts the number of observations for each category.\n\ncount(farm)     # count the number of observations\n\n\n\n\n\nn\n\n\n\n\n6\n\n\n\n\n\ncount(farm, type)     # count observations per type of farm\n\n\n\n\n\ntype\nn\n\n\n\n\ncrop\n2\n\n\ndairy\n1\n\n\nlivestock\n2\n\n\nurban\n1\n\n\n\n\n\ncount(farm, type, order = TRUE)     # add argument for order\n\n\n\n\n\ntype\norder\nn\n\n\n\n\ncrop\nTRUE\n2\n\n\ndairy\nTRUE\n1\n\n\nlivestock\nTRUE\n2\n\n\nurban\nTRUE\n1\n\n\n\n\n\ncount(farm, type, wt = return, sort = TRUE)     # add argument for weight\n\n\n\n\n\ntype\nn\n\n\n\n\nlivestock\n185\n\n\ncrop\n130\n\n\ndairy\n90\n\n\nurban\n50\n\n\n\n\n\n\n\n\n\n\n1.4 Export and Import Data\nThis section introduces functions in base R allowing you to export your data for later usage or import your saved data. To learn more about import/export data, check out this link.\n\n1.4.1 RData Format\n\n### export \nsave(farm, file = \"farm.Rdata\")     # save to the current working directory\n# specify the file path if you wish to save to a different location\n\n### import\nload(\"farm.Rdata\")      # load from the current working directory\n# specify the file path if your file is loaded \n\n\n\n1.4.2 csv Format\n\n### export\nwrite.csv(farm, \"farm.csv\")\n\n### import\nfarm &lt;- read.csv(\"farm.csv\")\n\n\n\n1.4.3 Other Format\nIf you are working with SPSS, Stata or SAS data files, haven is a good package for importing and exporting files of those formats.\n\n\n\n\n\n\nTip\n\n\n\nA handy trick to import data interactively, without the need of specifying a path, try read.csv(file.choose()).\n\n\n\n\n\n1.5 Useful Resources\n\n1.5.1 dplyr Cheat Sheet\nClick here for more information\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.5.2 R for Data Science\nSee Chapter 5 of R for Data Science, by Wickham, H., & Grolemund, G.\n\n\n\n1.6 Exercise\n\nPart A\nContinue from the farm business dataset “farm” used in Lab 2, work through the exercises below.\n\nCreate a new variable called size3 that meets the following criteria:\n\nsize3 = “small” if size &lt;= 200\nsize3 = “medium” if 200 &lt; size &lt;= 600\nsize3 = “big” if size &gt; 600\n\nFinally, convert size3 to a factor variable that is ordinal from “small” to “big”.\nGenerate the following summary statistics, for each type of the farms:\n\nthe sum of all returns, called tot.return\nthe average returns, called avg.return\n\nFinally, rearrange the data based on the value of avg.return, in the descending order.\n\n\n\nPart B\nImport data “mpg” and work through the coding below.\n\nDrop the variables displ, drv and fl, then exclude cars that were manufactured by Hyundai and Pontiac .\nContinue from your dataframe above and generate the summary statistics, for each manufacturer, model, and year:\n\nthe average of “cty”, called avg.cty\nthe average of “hwy”, called avg.hwy\nthe total number of cars produced, called tot.cars"
  },
  {
    "objectID": "labs/lab2.html#data-visualization-using-ggplot",
    "href": "labs/lab2.html#data-visualization-using-ggplot",
    "title": "Lab 2: Data Manipulation and Visualization",
    "section": "2 Data Visualization using ggplot",
    "text": "2 Data Visualization using ggplot\n\nlibrary(tidyverse) \nlibrary(gapminder) # for additional data\nlibrary(patchwork) # optional, used to show graphs side by side\n\n\n2.1 Introduction to ggplot2\nggplot2 is a plotting package that provides powerful commands to create graphs from data in a data frame. It offers a more programmatic interface for specifying which variables to plot, how they are displayed, and general visual properties. Therefore, we only need minimal changes if the underlying data change or if we decide to switch from a bar plot to a scatterplot. This helps in creating publication-quality plots with minimal adjustments and tweaking. Reference.\n\nThe “gg” here refers to “grammar of graphics”.\nEvery graph consists of one or more geometric layers.\n\nFor demonstration, we will use the built-in data set, mpg, first.\n\ndata(mpg)     \nhead(mpg)     \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\naudi\na4\n2.8\n1999\n6\nmanual(m5)\nf\n18\n26\np\ncompact\n\n\n\n\n\n\n\n\n2.2 Layered Grammar of Graphics\nFor our illustration of functions in ggplot2 in Lab 2, the layered grammar of graphics follows the template below. We will go through them step by step in the following sections.\n\n ggplot(data = &lt;DATA&gt;) + \n     &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) +\n     &lt;FACET_FUNCTION&gt; +\n     &lt;SCALE_FUNCTION&gt; +\n     &lt;LABS_FUNCTION&gt; +\n     &lt;THEME_FUNCTION&gt;\n\n\n\n2.3 Layers in ggplot2\n\n2.3.1 Geometric Layers\n\n2.3.1.1 Commonly Used geom Functions\nBelow is a list of commonly used geom functions, we will explore all of them in the rest of this section:\n\ngeom_point(): creates scatterplots\ngeom_line(): creates line plots\ngeom_bar(): creates bar charts of counts\ngeom_col(): creates bar charts of values\ngeom_boxplot(): shows distributions and outliers with boxplots\ngeom_smooth(): adds a fitted trend line\ngeom_jitter(): aids the visualization of points by adding “jitter” to their positions\n\n\n# create a scatter plot  \nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy)) \n\n\n\n\n\n\n\n# add another layer\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy), color = \"red\") +      # you can also request a specific color\n    geom_smooth(mapping = aes(x = displ, y = hwy))\n\n\n\n\n\n\n\n\nThe geom_xxx() functions can inherit both the data and aesthetic mappings from the top level of the plot, due to the argument inherit.aes = TRUE by default (as specified in the R Documentation). As a result, you can simplify your code as follows:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n    geom_point(color = \"red\") +\n    geom_smooth()\n\n\n\n\n\n\n\n\n\n\n2.3.1.2 Aesthetic Mapping\nRecall our previous code,\n\n\n\n\n\n\n\n\n\nAesthetics in geom_xxx() statement can be specified in two ways:\n\ninside the aes() function, which maps variables to aesthetics to represent or enhance visual features.\noutside the aes() function, which takes fixed values. This step is usually optional.\n\ngeom_xxx(aes(ARGUMENTS = variable, ...), ARGUMENTS = fixed values). Some commonly used aesthetics are:\n\nx, y: define the variables for the x- and y-axes (must be inside aes()).\ncolor: defines the color of lines and strokes.\nfill: defines the color inside areas of geoms.\nshape: defines the symbols of points.\nsize: defines the size of points.\nalpha: defines the opacity of geoms.\n\nThe examples below show the difference between mapping variables and mapping fixed values to aesthetics.\n\np1 &lt;- ggplot(data = mpg) +\n        geom_point(mapping = aes(x = displ, y = hwy, color = drv)) # map variable to color \n  \np2 &lt;- ggplot(data = mpg) +\n        geom_point(mapping = aes(x = displ, y = hwy), color = \"red\") # color now is mapped by a fixed value \n\np1 + p2 # enabled by \"patchwork\"              \n\n\n\n\n\n\n\n\n\np3 &lt;- ggplot(data = mpg) +\n        geom_point(mapping = aes(x = displ, y = hwy, shape = drv))  # map variable to shape \n  \np4 &lt;- ggplot(data = mpg) +\n        geom_point(mapping = aes(x = displ, y = hwy), shape = 2)  # shape now is mapped by a fixed value \n\np3 + p4               \n\n\n\n\n\n\n\n\n\np5 &lt;- ggplot(data = mpg) +\n        geom_point(mapping = aes(x = displ, y = hwy, size = drv))  # map variable to size \n  \np6 &lt;- ggplot(data = mpg) +\n        geom_point(mapping = aes(x = displ, y = hwy), size = 3)  # size now is mapped by a fixed value \n\np5 + p6               \n\n\n\n\n\n\n\n\n\np7 &lt;- ggplot(data = mpg) +\n        geom_point(mapping = aes(x = displ, y = hwy, alpha = drv))  # map variable to alpha \n  \np8 &lt;- ggplot(data = mpg) +\n        geom_point(mapping = aes(x = displ, y = hwy), alpha = 0.1)  # alpha now is mapped by a fixed value \n\np7 + p8               \n\n\n\n\n\n\n\n\n\np9 &lt;- ggplot(data = mpg) +\n        geom_bar(mapping = aes(x = class, fill = drv))  # map variable class to fill\n  \np10 &lt;- ggplot(data = mpg) +\n       geom_bar(mapping = aes(x = class), fill = \"red\")  # fill now is mapped by a fixed value \n\np9 + p10               \n\n\n\n\n\n\n\n\n\n\n2.3.1.3 Commonly Used Fixed Values\nAs shown above, fixed values mapped to aesthetics are usually numbers or strings. Below are some commonly used fixed values for geom functions:\n\ncolor and fill: see R color cheatsheet.\nlinetype and shape: see Cookbook for R\nsize: takes numeric values; larger values correspond to larger sizes.\nalpha: takes values between 0 and 1; larger values correspond to less transparency.\nSome extra examples are shown below\n\n\nmpg_class_year_hwy &lt;- mpg %&gt;% group_by(class, year) %&gt;% summarize(mean_hwy = mean(hwy))\n\np11 &lt;- ggplot(data = mpg_class_year_hwy, aes(year, mean_hwy, color = class)) +\n        geom_line(size = 2, linetype = \"dotdash\")   \n  \np12 &lt;- ggplot(data = mpg_class_year_hwy, aes(year, mean_hwy, color = class)) +\n        geom_line(size = 2, linetype = 4) +\n        geom_point(size = 4, shape = 15)\n\np11 + p12               \n\n\n\n\n\n\n\n\n\nmpg_class_hwy &lt;- mpg %&gt;% group_by(class) %&gt;% summarize(mean_hwy = mean(hwy))\n\np13 &lt;- ggplot(data = mpg_class_hwy, mapping = aes(x = class, y = mean_hwy)) +\n        geom_col(fill = \"lightblue1\")  \n  \np14 &lt;- ggplot(data = mpg_class_hwy, mapping = aes(x = class, y = mean_hwy)) +\n        geom_col(fill = \"lightblue3\")   \n\np13 + p14               \n\n\n\n\n\n\n\n\n\np15 &lt;- ggplot(data = mpg, aes(x = drv, y = hwy, color = drv)) +\n        geom_boxplot() \n  \np16 &lt;- ggplot(data = mpg, aes(x = drv, y = hwy, color = drv)) +\n        geom_boxplot() + \n        geom_jitter(width = 0.333) \n\np15 + p16               \n\n\n\n\n\n\n\n\n\n\n\n2.3.2 Facets\nfacet_wrap(): partitions a plot into a matrix of panels, typically based on the values of one faceting variable. Each panel shows a different subset of the data.\nfacet_grid(): partitions a plot into a matrix of panels, based on the combination of two faceting variables.\nFollowing the previous practice, let us create a line plot to show the trend of average fuel efficiency for each manufacturer.\n\nmpg_mfr_year_hwy &lt;- mpg %&gt;% group_by(manufacturer, year) %&gt;% summarize(mean_hwy = mean(hwy))\n \np17 &lt;- ggplot(data = mpg_mfr_year_hwy, aes(year, mean_hwy, color = manufacturer)) +\n        geom_line(size = 2)\n  \np18 &lt;- ggplot(data = mpg_mfr_year_hwy, aes(year, mean_hwy, color = manufacturer)) +\n        geom_line(size = 2) + \n        facet_wrap(~ manufacturer) \n\np17 + p18               \n\n\n\n\n\n\n\n\nAs you can see in “p17”, the graph is not effective in showing the trend in fuel efficiency across time for some of the manufacturers. “p18” partitions the plot into subplots for each individual manufacturer. Since all panels share the same scale for “mean_hwy”, the graph is still not effective. To improve, you can add scales = \"free\" to allow different scales for subplots.\n\np19 &lt;- ggplot(data = mpg_mfr_year_hwy, aes(year, mean_hwy, color = manufacturer)) +\n        geom_line(size = 2) + \n        facet_wrap(~ manufacturer, scales = \"free\")  \n\np18 + p19               \n\n\n\n\n\n\n\n\nNow, let’s see how facet_wrap() differs from facet_grid(), starting with graph(s) showing “hwy” vs. “displ”.\n\np20 &lt;- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n        geom_point() +\n        geom_smooth()\n\np21 &lt;- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n        geom_point() +\n        geom_smooth() +\n        facet_wrap(~drv)\n\np20 + p21\n\n\n\n\n\n\n\n\nAs shown below, facet_wrap() shows the relationship for each value of “drv”, while facet_grid() shows the relationship for each combinations of the values of “drv” and fl.\n\np22 &lt;- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n        geom_point() +\n        geom_smooth() +\n        facet_wrap(~drv, nrow = 3, strip.position = \"right\") # adding nrow and strip.position for better visualization\n\np23 &lt;- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n        geom_point() +\n        geom_smooth() +\n        facet_grid(drv ~ fl)\n\np22 + p23\n\n\n\n\n\n\n\n\n\n\n2.3.3 Scales\n\n2.3.3.1 Scales of Axes\nThis section explores some common functions that scale the axes of your graph.\n\nWhen mapping discrete variables: the default functions are scale_x_discrete() for the x-axis, and scale_y_discrete() for the y-axis.\nWhen mapping continuous variables: the default functions are scale_x_continuous() for the x-axis, and scale_y_continuous() for the y-axis.\n\nBuilt-in functions like scale_x_log10(), scale_x_sqrt(), and scale_x_reverse() provide easy access to common transformations: base-10 logarithm, square root, and reversed order.\n\n\nFor this section, let’s use a new dataset from the package gapminder. See how arguments limits controls the min/max of the axes, and breaks displays ticks only at specified values.\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   &lt;fct&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\nbase_plot &lt;- ggplot(gapminder, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n              geom_point() \n\nscale_x_y &lt;- base_plot + \n              scale_x_continuous(limits = c(0, 50000), breaks = c(10000, 25000, 50000)) +\n              scale_y_continuous(limits = c(40, 70), breaks = c(40, 50, 70))\n\nbase_plot + scale_x_y\n\n\n\n\n\n\n\n\n\nbuilt_in_log10 &lt;- base_plot + scale_x_log10()\n\nmanual_log10 &lt;- ggplot(gapminder, aes(x = log10(gdpPercap), y = lifeExp, color = continent)) +\n                  geom_point() \n\nbuilt_in_log10 + manual_log10\n\n\n\n\n\n\n\n\n\nbase_plot_reverse &lt;- base_plot + scale_x_reverse() + scale_y_reverse()\n \nbase_plot + base_plot_reverse\n\n\n\n\n\n\n\n\n\n\n2.3.3.2 Scales of Colors\nRecall you can set the color of your graphs using the aesthetics color and/or fill.\n\n# building a simple dataframe\nmydata &lt;- data.frame(x = c(\"a\", \"b\", \"c\", \"d\"), y = c(1, 2, 3, 4))\nmydata\n\n\n\n\n\nx\ny\n\n\n\n\na\n1\n\n\nb\n2\n\n\nc\n3\n\n\nd\n4\n\n\n\n\n\nbar_color &lt;- ggplot(mydata, aes(x = x, y = y, color = x)) + geom_col()\nbar_fill  &lt;- ggplot(mydata, aes(x = x, y = y, fill = x))  + geom_col()\n\nbar_color + bar_fill\n\n\n\n\n\n\n\nbar_color_scale &lt;- bar_color + scale_color_discrete()  # since x is discrete now\nbar_fill_scale  &lt;- bar_fill  + scale_fill_discrete()  \n\nbar_color_scale + bar_fill_scale # no changes since we are using defaults \n\n\n\n\n\n\n\n\nTo assign different colors to different values of “x”, we can utilize the function scale_fill_brewer(), which uses the color palettes from the package RColorBrewer without the need of installing and loading the package. To see all the colors, check this link or type RColorBrewer::display.brewer.all().\n\nbar_fill_brewer_1 &lt;- bar_fill + scale_fill_brewer(palette = \"OrRd\")\n\nbar_fill_brewer_2 &lt;- bar_fill + scale_fill_brewer(palette = \"BrBg\")\n\nbar_fill_brewer_1 + bar_fill_brewer_2\n\n\n\n\n\n\n\n\n\n\n\n2.3.4 Labs and Themes\nTo modify elements of a plot other than the data, such as axes, legend, or title, use labs() and theme(). See how the example below applies changes to the graph “bar_fill” on axis, legend and plot title.\n\nbar_fill_mod &lt;- bar_fill + labs(x = \"Letters\", y = \"Numbers\", fill = \"Legend\", title = \"bar_fill Modified\") +\n                                theme(\n                                  axis.title = element_text(size = 24),\n                                  axis.text = element_text(size = 20),\n                                  axis.text.x = element_text(angle = 45),\n                                  \n                                  legend.title = element_text(size = 16),\n                                  legend.text = element_text(size = 12),\n                                  legend.position = \"bottom\",\n                                  \n                                  plot.title = element_text(size = 30, face = \"bold\")\n                                )\n        \n\nbar_fill + bar_fill_mod\n\n\n\n\n\n\n\n\n\n\n2.3.5 Built-in Themes\nThere are a number of built-in themes come with ggplot2 that you can use without the need to specify every element of your graphs. The default theme of ggplot2 is theme_grey(). Let’s see some examples on our base plot below.\n\nbase_theme &lt;- ggplot(data = mpg, aes(x = displ, y = hwy)) +\n                geom_point(color = \"red\") +\n                geom_smooth() +\n                labs(x = \"Engine Displacement\", y = \"Highway Mileage\", title = \"Fuel Efficiency\") \nbase_theme  \n\n\n\n\n\n\n\n\n\nbase_theme_default &lt;- base_theme + theme_grey() + labs(title = \"theme_grey()\")\n        \nbase_theme1 &lt;- base_theme + theme_bw() + labs(title = \"theme_bw()\")\n\nbase_theme2 &lt;- base_theme + theme_classic() + labs(title = \"theme_classic()\")\n\nbase_theme3 &lt;- base_theme + theme_minimal() + labs(title = \"theme_minimal()\")\n        \nbase_theme4 &lt;- base_theme + theme_linedraw() + labs(title = \"theme_linedraw()\")\n\nbase_theme5 &lt;- base_theme + theme_light() + labs(title = \"theme_light()\")\n\nbase_theme6 &lt;- base_theme + theme_dark() + labs(title = \"theme_dark()\")\n\nbase_theme7 &lt;- base_theme + theme_void() + labs(title = \"theme_void()\")\n\n(base_theme_default + base_theme1 + base_theme2 + base_theme3 +\n base_theme4 + base_theme5 + base_theme6 + base_theme7) + \n  plot_layout(ncol = 4, nrow = 2)\n\n\n\n\n\n\n\n\nExtra themes and scales can be acquired by installing package ggthemes. To see the complete list, visit this webiste.\n\n\n\n2.4 Annotating and Saving Plots\nSometimes, you may wish to add text in your graphs to highlight certain elements. Take “base_plot” in Section 2.3.3 for example, say you wish to highlight countries with high GDP per capita (above $50,000) but low life expectancy (below 70 years old).\n\nh_country &lt;- gapminder %&gt;% filter(gdpPercap &gt; 50000 & lifeExp &lt; 70) # create the data that's to be highlighted in the graph\n\nbase_plot_text &lt;- base_plot + \n                    geom_text(data = h_country, aes(label = country), size = 4, vjust = 1.5, show.legend = FALSE) + \n                    geom_text(data = h_country, aes(label = year), size = 4, vjust = 2.75, show.legend = FALSE) \n\nbase_plot + base_plot_text\n\n\n\n\n\n\n\n\nTo save a created plot, you can use the function ggsave() as below.\n\nggsave(\"gdp_lifeExp.png\", plot = base_plot_text, width = 10, height = 7)  # save to your current working directory\n\n# you can save ggplot as one of \"eps\", \"ps\", \"tex\", \"pdf\", \"jpeg\", \"tiff\", \"png\", \"bmp\", \"svg\" or \"wmf\" \n# you can also use different units = c(\"in\", \"cm\", \"mm\", \"px\"),  \n# ggsave(\"myplot.pdf\", width = 20, height = 20, units = \"cm\")\n\n\n\n2.5 Useful resources\n\n2.5.1 ggplot2 Cheat Sheet\nClick here for more information\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.5.2 R for Data Science\nSee Chapter 3 and 28 of R for Data Science, by Wickham, H., & Grolemund, G.\n\n\n2.5.3 ggplot2: Elegant Graphics for Data Analysis\nSee the third edition of ggplot2: Elegant Graphics for Data Analysis, by Hadley Wickham, Danielle Navarro, and Thomas Lin Pedersen.\n\n\n\n2.6 Exercise\n\nPart A\nImport data “mpg” and work through the exercises below.\n\nCreate a scatterplot that shows all of the following:\n\nuse “cty” on the x-axis and “hwy” on the y-axis\nassign different colors for “class” and different shapes for “year”.\n(tip: since continuous variables cannot be mapped to shape, you will need to convert “year” to a factor using factor())\nfit only one trend line for all points\n\nCreate a scatterplot that shows all of the following:\n\nuse “displ” on the x-axis and “hwy” on the y-axis\npartition the graph into a grid by the combination of “drv” and “fl”, but only include “fl” that equals “p” or “r”\nfit a trend line in each graph within the grid\n\n(Tip: you can build from the example “p23” in Lab 2.)\nCreate a bar chart that shows the average “hwy” of all cars produced in 2008 by each of the following manufacturers:\nAudi, Hyundai, Nissan and Volkswagen. Assign a different color to each manufacturer.\n\n\n\nPart B\nImport the data “gapminder” and try to reproduce the graph below."
  },
  {
    "objectID": "labs/answerkey.html",
    "href": "labs/answerkey.html",
    "title": "Exercise - Answer Key",
    "section": "",
    "text": "The answer key is currently withheld and will be made available within one week after the lab."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Labs",
    "section": "",
    "text": "Welcome! This website is for the R labs for AREC513 - Econometric Applications (Fall 2025) taught by Dr. Feng Qiu.\n\nSchedule\nThe lab sessions will take place in GSB 7-11 from 2:00 – 3:50 PM on the following dates:\n\nLab 1 (by Liyuan Xuan) — Sept 15\nLab 2 (by Liyuan Xuan) — Sept 22\nLab 3 (by Liyuan Xuan) — Sept 29\nLab 4 (by Liyuan Xuan) — Oct 20\nLab 5 (by Liyuan Xuan) — Oct 27\nLab 6 (by Liyuan Xuan) — Nov 10\nLab 7 (by Feng Qiu) — Nov 24\nLab 8 (by Feng Qiu) — Dec 8\n\n\n\nSoftware\nThe software will be used for the lab sessions are R and RStudio. For instruction regarding installation, please navigate to Lab 1.\n\n\nAcknowledgement\nPart of the code used in this website is adapted from Dr. Qiu’s previous handouts for AREC 513.\n\n\nContact\nThe website is maintained by Liyuan Xuan. For questions or suggestions, feel free to contact Liyuan at lxuan@ualberta.ca."
  },
  {
    "objectID": "labs/lab1.html",
    "href": "labs/lab1.html",
    "title": "Lab 1: Introduction to R",
    "section": "",
    "text": "R\nR is a free software environment for statistical computing and graphics. To download, go to CRAN and select the installer for your operating system (Windows, Mac, or Linux).\nRStudio\nRStudio is a user-friendly application that helps you write in R and enhances your programming experience. To download, visit this website and select the installer for your operating system.\n\nAfter R and RStudio are installed, we will only need to use RStudio for this and future labs. The default RStudio layout has three panes: Console, Environment, and Output.\n\n\n\n\n\nscreenshot of RStudio\n\n\n\n\nYou can customize your RStudio working environment via Tools &gt; Global Options in the top menu bar."
  },
  {
    "objectID": "labs/lab1.html#download-and-install",
    "href": "labs/lab1.html#download-and-install",
    "title": "Lab 1: Introduction to R",
    "section": "",
    "text": "R\nR is a free software environment for statistical computing and graphics. To download, go to CRAN and select the installer for your operating system (Windows, Mac, or Linux).\nRStudio\nRStudio is a user-friendly application that helps you write in R and enhances your programming experience. To download, visit this website and select the installer for your operating system.\n\nAfter R and RStudio are installed, we will only need to use RStudio for this and future labs. The default RStudio layout has three panes: Console, Environment, and Output.\n\n\n\n\n\nscreenshot of RStudio\n\n\n\n\nYou can customize your RStudio working environment via Tools &gt; Global Options in the top menu bar."
  },
  {
    "objectID": "labs/lab1.html#working-directory",
    "href": "labs/lab1.html#working-directory",
    "title": "Lab 1: Introduction to R",
    "section": "2 Working Directory",
    "text": "2 Working Directory\nThe working directory is a folder path on your computer that sets the default location for files you read into R or save out of R. Think of it as a little “flag” on your computer tied to your project.\n\nTo find your current working directory, type the code below in your Console pane and press Enter.\n\ngetwd()\n\n[1] \"D:/University of Alberta/0. Teaching/AREC513/Fall2025/labs\"\n\n\nTo change your current working directory, you can\n\nUse the code below\n\n\nsetwd(\"C:/Program Files\")  \n\n\n\n\n\n\n\nTip\n\n\n\nIn R, file paths are separated by forward slash /, not backward slash \\. The full path needs to be wrapped with the double quotations \" \"\n\n\n\nUse the top menu bar Session &gt; Set Working Directory &gt; Choose Directory\nTo set a default working directory, go to Tools &gt; Global Options &gt; General &gt; Default working directory"
  },
  {
    "objectID": "labs/lab1.html#r-basics",
    "href": "labs/lab1.html#r-basics",
    "title": "Lab 1: Introduction to R",
    "section": "3 R Basics",
    "text": "3 R Basics\n\n3.1 Calculations\n\n1 + 1\n\n[1] 2\n\n5 * 6\n\n[1] 30\n\n2 ^ 4\n\n[1] 16\n\n(8 + 5 * 6 / 3) / 2\n\n[1] 9\n\n\n\n\n3.2 Creating Objects\n\na &lt;- 5 * 6\na\n\n[1] 30\n\nb &lt;- 8 + a / 3\nb\n\n[1] 18\n\nc &lt;- \"AREC 513\"\nc\n\n[1] \"AREC 513\"\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn RStudio, you can use the shortcut Alt + - (hyphen) to write the assignment operator &lt;-.\n\n\n\n\n3.3 Data Types\nThere are four main data types in R we will use in the labs: numeric, integer, logical, and character.\n\nNumeric data, also known as quantitative data\n\nis.numeric(b)     # test if the object \"b\" is numeric\n\n[1] TRUE\n\n\nInteger data, stores whole numbers without decimals\n\nd &lt;- 8L     # to generate integer variable, add \"L\" after the number\nis.integer(d)\n\n[1] TRUE\n\n\nLogical data, stores only TRUE or FALSE\n\ne &lt;- TRUE\nis.logical(e)\n\n[1] TRUE\n\n\nCharacter data, stores text strings\n\nis.character(c)\n\n[1] TRUE\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can also use class() to check the class of an object. For example, try class(a).\n\n\nTo convert your objects to a specific type, use as.numeric(), as.integer(), as.logical(), or as.character().\n\n\n3.4 Data Structures\nWhen analyzing data, you rarely deal with objects that store one single value or datasets with one single variable. This section discusses some common data structures.\n\n3.4.1 Vectors\n\n3.4.1.1 Create a Vector\nVectors play a crucial role in R, R is a vectorized language. A vector is a collection of values/elements, all of the same type. We can use the function c() to create a vector, which means “combine”.\n\ngrades_1 &lt;- c(75, 76, 77, 78, 79, 80, 81, 82, 83, 84)\ngrades_1\n\n [1] 75 76 77 78 79 80 81 82 83 84\n\ngrades_2 &lt;- c(75:84) # to generate continuous values from 75 to 80, you can use \":\" directly.\ngrades_2\n\n [1] 75 76 77 78 79 80 81 82 83 84\n\nnames &lt;- c(\"Marshall\", \"Ruby\", \"Peppa\", \"George\", \"Suzy\", \"Danny\", \n           \"Pedro\", \"Rebecca\", \"Rubble\", \"Ryder\", \"Max\", \"Chase\")\nnames\n\n [1] \"Marshall\" \"Ruby\"     \"Peppa\"    \"George\"   \"Suzy\"     \"Danny\"   \n [7] \"Pedro\"    \"Rebecca\"  \"Rubble\"   \"Ryder\"    \"Max\"      \"Chase\"   \n\n\n\n\n3.4.1.2 Vector Operations\n\ngrades_1 + 5 # operations apply to each element in the vector\n\n [1] 80 81 82 83 84 85 86 87 88 89\n\ngrades_1 * 2\n\n [1] 150 152 154 156 158 160 162 164 166 168\n\nsqrt(grades_1)\n\n [1] 8.660254 8.717798 8.774964 8.831761 8.888194 8.944272 9.000000 9.055385\n [9] 9.110434 9.165151\n\ngrades_1 &gt;= 78\n\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\ngrades_1 == 78\n\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen testing for equality, double == has to be used.\n\n\n\n\n3.4.1.3 Factor Vectors\nFactor variables are important when building statistical models. There are two types of factor variable,\n\nnominal: categorical variable with no inherent order among the categories\n\n\njbp &lt;- c(\"poor\", \"excellent\", \"fair\", \"poor\", \"good\") # create a nominal job performance vector\njbp\n\n[1] \"poor\"      \"excellent\" \"fair\"      \"poor\"      \"good\"     \n\nclass(jbp)\n\n[1] \"character\"\n\njbp.1 &lt;- as.factor(jbp)     # converting your character vector to factor\njbp.1\n\n[1] poor      excellent fair      poor      good     \nLevels: excellent fair good poor\n\nclass(jbp.1)\n\n[1] \"factor\"\n\n\n\nordinal: categorical variable with a defined ranking among the categories\n\n\n# create a job performance vector, that is nominal\njbp.2 &lt;- factor(jbp, levels = c(\"poor\", \"fair\", \"good\", \"excellent\"))     # assigning an ordinal ranking\njbp.2\n\n[1] poor      excellent fair      poor      good     \nLevels: poor fair good excellent\n\n\n\n\n3.4.1.4 Subset Vectors and Select Elements\nTo subset a vector or select certain elements from a vector, we use the square brackets [ ].\n\nBy Position\n\ngrades_1[1]         # select the 1st element\n\n[1] 75\n\ngrades_1[-2]        # exclude the 2nd element\n\n[1] 75 77 78 79 80 81 82 83 84\n\ngrades_1[3:5]       # select elements 3 to 5\n\n[1] 77 78 79\n\ngrades_1[c(1,3,5)]  # select the 1st, 3rd, and 5th elements\n\n[1] 75 77 79\n\n\nBy Condition\n\ngrades_1[grades_1 &gt;= 78]               # select grades_1 that are equal or above 78\n\n[1] 78 79 80 81 82 83 84\n\ngrades_1[grades_1 != 78]               # select grades_1 that do not equal to 78\n\n[1] 75 76 77 79 80 81 82 83 84\n\njbp.2[jbp.2 %in% c(\"poor\", \"fair\")]    # select job performance that is \"poor\" or \"fair\" \n\n[1] poor fair poor\nLevels: poor fair good excellent\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf you wish to apply multiple conditions, the common operators are & (Shift + 7) for AND and | (Shift + \\) for OR. Try grades_1[grades_1 &gt;= 78 & grades_1 != 80].\n\n\n\n\n\n\n3.4.2 Matrices\nA matrix is a collection of data elements arranged in a two-dimensional rectangular layout. The elements of a matrix must be of the same type of data. Matrices are commonly used in mathematics and statistics. Math matrices and R matrices are different concepts. Matrices in R are broader.\n\nma.1 &lt;- matrix(1:15, nrow = 5, ncol =3)\nma.1\n\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\nma.2 &lt;- matrix(names, nrow = 6, ncol = 2)\nma.2\n\n     [,1]       [,2]     \n[1,] \"Marshall\" \"Pedro\"  \n[2,] \"Ruby\"     \"Rebecca\"\n[3,] \"Peppa\"    \"Rubble\" \n[4,] \"George\"   \"Ryder\"  \n[5,] \"Suzy\"     \"Max\"    \n[6,] \"Danny\"    \"Chase\"  \n\n\nSince matrices are two-dimensional, to subset or select elements from a matrix using [ ], you need to define row and/or column index in [ROW, COL].\n\nma.1[2, ]   # select all elements in the 2nd row of ma.1\n\n[1]  2  7 12\n\nma.1[, 2]   # select all elements in the 2nd column of ma.1\n\n[1]  6  7  8  9 10\n\nma.1[2, 2]  # select the element in row 2 and column 2 of ma.1\n\n[1] 7\n\nma.2[3, 2]  # select the element in row 3 and column 2 of ma.2\n\n[1] \"Rubble\"\n\n\n\n\n3.4.3 Arrays\nIn R, arrays are the data objects that can store data in more than two dimensions. Data need to be the same type.\n\narray.1 &lt;- array(1:24, dim = c(2, 3, 4))      # 2 rows * 3 columns * 4 matrices\narray.1\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]   13   15   17\n[2,]   14   16   18\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]   19   21   23\n[2,]   20   22   24\n\n\n\n\n3.4.4 Lists\nLists are R objects that can contain multiple components of different data types, data structures, and dimensions.\n\nnames\n\n [1] \"Marshall\" \"Ruby\"     \"Peppa\"    \"George\"   \"Suzy\"     \"Danny\"   \n [7] \"Pedro\"    \"Rebecca\"  \"Rubble\"   \"Ryder\"    \"Max\"      \"Chase\"   \n\ngrades_1\n\n [1] 75 76 77 78 79 80 81 82 83 84\n\nlist.1 &lt;- list(name = names, grade = grades_1, random_num = 9)      # create a list with 3 components\nlist.1\n\n$name\n [1] \"Marshall\" \"Ruby\"     \"Peppa\"    \"George\"   \"Suzy\"     \"Danny\"   \n [7] \"Pedro\"    \"Rebecca\"  \"Rubble\"   \"Ryder\"    \"Max\"      \"Chase\"   \n\n$grade\n [1] 75 76 77 78 79 80 81 82 83 84\n\n$random_num\n[1] 9\n\nnames(list.1)\n\n[1] \"name\"       \"grade\"      \"random_num\"\n\n\nTo select from a list, you can keep using index numbers with square brackets [ ], or you can use the extractor operator $.\n\nlist.1[1]     # create a new list with only the 1st component from list.1\n\n$name\n [1] \"Marshall\" \"Ruby\"     \"Peppa\"    \"George\"   \"Suzy\"     \"Danny\"   \n [7] \"Pedro\"    \"Rebecca\"  \"Rubble\"   \"Ryder\"    \"Max\"      \"Chase\"   \n\nlist.1[[1]]   # extract all elements from the 1st component of list.1 (i.e. the name vector)\n\n [1] \"Marshall\" \"Ruby\"     \"Peppa\"    \"George\"   \"Suzy\"     \"Danny\"   \n [7] \"Pedro\"    \"Rebecca\"  \"Rubble\"   \"Ryder\"    \"Max\"      \"Chase\"   \n\nlist.1$name   # extract all the elements from the component named \"name\" from list.1\n\n [1] \"Marshall\" \"Ruby\"     \"Peppa\"    \"George\"   \"Suzy\"     \"Danny\"   \n [7] \"Pedro\"    \"Rebecca\"  \"Rubble\"   \"Ryder\"    \"Max\"      \"Chase\"   \n\nlist.1[[1]][1]\n\n[1] \"Marshall\"\n\nlist.1$name[1]\n\n[1] \"Marshall\"\n\n\n\n\n3.4.5 Data Frames\nA data frame is a list whose elements are equal-length vectors, and vectors can be different data types. Basically, a data frame is a limited version of a list, or a flexible version of a matrix. In a data frame, vectors/variables can be different types, but the length needs to be the same.\n\ndf1 &lt;- data.frame(Name = names[1:10], Grade = grades_1)\ndf1\n\n\n\n\n\nName\nGrade\n\n\n\n\nMarshall\n75\n\n\nRuby\n76\n\n\nPeppa\n77\n\n\nGeorge\n78\n\n\nSuzy\n79\n\n\nDanny\n80\n\n\nPedro\n81\n\n\nRebecca\n82\n\n\nRubble\n83\n\n\nRyder\n84\n\n\n\n\n\ndf1$Name\n\n [1] \"Marshall\" \"Ruby\"     \"Peppa\"    \"George\"   \"Suzy\"     \"Danny\"   \n [7] \"Pedro\"    \"Rebecca\"  \"Rubble\"   \"Ryder\"   \n\ndf1$Grade[1:5]\n\n[1] 75 76 77 78 79\n\ndf1$Grade[df1$Grade &gt;= 80]\n\n[1] 80 81 82 83 84\n\ndf1$Name[df1$Grade &gt;= 80]\n\n[1] \"Danny\"   \"Pedro\"   \"Rebecca\" \"Rubble\"  \"Ryder\"  \n\ndf1[df1$Grade &gt;= 80, ]\n\n\n\n\n\n\nName\nGrade\n\n\n\n\n6\nDanny\n80\n\n\n7\nPedro\n81\n\n\n8\nRebecca\n82\n\n\n9\nRubble\n83\n\n\n10\nRyder\n84\n\n\n\n\n\nmean(df1$Grade)\n\n[1] 79.5"
  },
  {
    "objectID": "labs/lab1.html#r-packages",
    "href": "labs/lab1.html#r-packages",
    "title": "Lab 1: Introduction to R",
    "section": "4 R Packages",
    "text": "4 R Packages\nTo extend the capabilities of R, various packages are developed to handle different tasks: data manipulation, analysis, and visualization.\n\n4.1 Base Packages\nThe base packages providing basic functions and datasets are pre-included with R installation. For example, the package datasets, which provides a collection of datasets.\n\nTry data(), which returns the list of datasets within this package.\nTo load one of the listed datasets, e.g. mtcars, type data(mtcars). This dataset provides statistics from road tests on multiple models of cars.\n\n\n\n4.2 Contributed Packages\nMany other contributed packages, designed to implement specific operations, are not included with R by default. To utilize these packages, we need to install and load them individually.\n\nInstall a package, type install.packages(\"tidyverse\")\nLoad the installed package, type library(tidyverse)\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen installing, the package names must be in quotes \" \". When loading, they are not necessary.\n\n\nAfter loading the package, we can use the functions in tidyverse. tidyverse is a collection of packages, such as dplyr and tidyr for data manipulation, ggplot2 for data visualization, lubridate for processing time-series data.\n\nExample with select from dplyr, type ?select first to see the R Documentation for this function.\n\ndata(mpg)     # new dataset mpg also comes with tidyverse\n\nhead(mpg)     # head() displays the first 6 observations of a dataset\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\naudi\na4\n2.8\n1999\n6\nmanual(m5)\nf\n18\n26\np\ncompact\n\n\n\n\n\nhead(select(mpg, c(manufacturer, model, year)))      # select() selects named variables from a data frame\n\n\n\n\n\nmanufacturer\nmodel\nyear\n\n\n\n\naudi\na4\n1999\n\n\naudi\na4\n1999\n\n\naudi\na4\n2008\n\n\naudi\na4\n2008\n\n\naudi\na4\n1999\n\n\naudi\na4\n1999\n\n\n\n\n\nhead(filter(mpg, year &gt;= 2000))     # filter() subsets a data frame based on defined conditions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\naudi\na4\n3.1\n2008\n6\nauto(av)\nf\n18\n27\np\ncompact\n\n\naudi\na4 quattro\n2.0\n2008\n4\nmanual(m6)\n4\n20\n28\np\ncompact\n\n\naudi\na4 quattro\n2.0\n2008\n4\nauto(s6)\n4\n19\n27\np\ncompact\n\n\naudi\na4 quattro\n3.1\n2008\n6\nauto(s6)\n4\n17\n25\np\ncompact\n\n\n\n\n\n\nSee how packages simplify the code and make it more intuitive. More details about tidyverse will be discussed in Lab 2."
  },
  {
    "objectID": "labs/lab1.html#r-script",
    "href": "labs/lab1.html#r-script",
    "title": "Lab 1: Introduction to R",
    "section": "5 R Script",
    "text": "5 R Script\nR script is simply a text file containing a set of commands and comments, which allows you to save, edit, and execute your code. To create an R script, in the top toolbar, select File &gt; New File &gt; R Script.\nOpening an R script creates a new pane to your RStudio, the Source pane. In this pane, you can edit and save your code. To run your code, you can hold Ctrl and press Enter, or click the Run button. This will run through your entire R script, or your selected lines of code.\n\n\n\n\n\nThe Source Pane and R Sript\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAll lines entered in an R script are interpreted as code to be run by R, unless they begin with # (Shift + 3). Using # is useful for documenting and explaining your code, or for temporarily disabling sections of code."
  },
  {
    "objectID": "labs/lab1.html#useful-resources",
    "href": "labs/lab1.html#useful-resources",
    "title": "Lab 1: Introduction to R",
    "section": "6 Useful Resources",
    "text": "6 Useful Resources\nThis section lists some useful resources for your exploration of R.\n\n6.1 Base R Cheat Sheet\nClick here for more information\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.2 An Introduction to R\nAn Introduction to R, by Venables, W. N., Smith, D. M., & R Development Core Team"
  },
  {
    "objectID": "labs/lab1.html#exercise",
    "href": "labs/lab1.html#exercise",
    "title": "Lab 1: Introduction to R",
    "section": "7 Exercise",
    "text": "7 Exercise\nLoad the dataset “mpg” and work through the exercises below. Note, “mpg” is included in the tidyverse package, so you will need to load the package first.\n\nCalculate the mean, range, minimum, and maximum of the variable “hwy” across all models. Then, combine these statistics into one vector. (Tip: look up the RDocumentation for the functions mean, range, min, and max).\nSince “hwy” is measured in miles per gallon, create a new variable in mpg that expresses “hwy” in litres per 100 km.\nIdentify the models of cars that are most fuel-efficient. Which classes of cars are least fuel-efficient?\nCompute the quantiles of “hwy”. Can you also calculate the tertiles instead? (Tip: look up for the RDocumentation for the function quantile).\nNow, based on the tertiles you calculated, assign “least efficient”, “medium”, and “most efficient” labels to all models. Try using both base R indexing and the function ifelse."
  }
]