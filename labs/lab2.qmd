---
title: "Lab 2: Data Manipulation and Visualization"
author: "Feng Qiu, Liyuan Xuan"
date: "Sept 22, 2025"
format:
  html:
    toc: true
    toc-title: "Section"
---
 
In Lab 1, we briefly introduced what packages are in R and one specific package *tidyverse*. If you wish to learn more about *tidyverse*, [click here for more information](https://www.tidyverse.org/). Lab 2 will focus on two packages that are included in *tidyverse*:

1. *dplyr* for data manipulation

2. *ggplot* for data visualization

But first, remember to load the package.

```{r}
# install.packages("tidyverse")     # install if needed
library(tidyverse)
```

## Data Manipulation using dplyr

### What is a tidy data set?

Tidy data is a standard way of mapping the meaning of a dataset to its structure. A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types. Three rules make a data tidy:

1. Each variable must have its own column

2. Each observation must have its own row

3. Each value must have its own cell

### Create a farm business data set

```{r}
# farmers' info
name <- c("Henry", "Larry", "Alex", "Gaby", "Amy", "Ruby")
sex <- c("male", "male", "male", "female", "female", "female")
age <- c(43, 60, 25, 50, 28, 58)

# types of farm
type <- c("crop", "livestock", "urban", "dairy", "crop", "livestock")

# size of farm in acres
size <- c(550, 800, 10, 600, 1000, 700)

# net annual cash return from ag businesses, in $1000
return <- c(40, 90, 50, 90, 90, 95)

# combine the variables together as a data frame
farm <- data.frame(name, age, sex, type, size, return)
farm

# glimpse the data set
glimpse(farm)
```

### Important Functions in dplyr

There are six important functions in *dplyr* are:

1. `select()`: pick variables by their names

2. `filter()`: pick observations by their values

3. `arrange()`: reorder the rows

4. `mutate()`: create new variables with functions of existing variables

5. `summarize()`: collapse many values down to a single summary

6. `group_by()`: groups data by one or more variables, allowing subsequent operations to be applied independently to each group

Combining with the pipe operator `%>%`, *dplyr* can make data manipulation simple and intuitive.

:::callout-tip
You can always type "?FUNCTION_NAME" in the Console pane to check the R Documentation for the function. Try `?select`.
:::

#### `select()`

`select()` allows you to focus on the variables you’re interested in. 

```{r}
select(farm, c(type, size, return))     # select farm type, size and return
select(farm, sex:size)      # select everything between sex and size
select(farm, -name)     # select everything but names
```

#### `filter()`

`filter()` allows you to subset observations based on their values.

```{r}
filter(farm, size > 500)      # select farms with size > 500
filter(farm, size > 500 & sex == "female")      # select farms with size > 500 AND owned by female farmers
```

#### `arrange()`

`arrange()` orders the observations by one or more variables. Basically, it changes the order of rows.

```{r}
arrange(farm, size)      # order the data set by farm size, by default, in ascending order
arrange(farm, desc(size))      # change the ordering to descending
```

#### `mutate()`

`mudate()` modifies existing variables or adds new variables.

```{r}
mutate(farm, return = return * 1000)
mutate(farm, age.sq = age ^ 2)
mutate(farm, per.acre.return = return / size)

# Or, you can do all three in one step
mutate(farm,
  return = return * 1000, 
  age.sq = age ^ 2,
  per.acre.return = return / size
)

# change the classes of variables
glimpse(farm)      # view the data before changes
farm2 <- mutate(farm,
                sex = as.factor(sex), 
                type = as.factor(type), 
                age = as.integer(age)
         )
glimpse(farm2)       # view the data after changes

```

The function `else()` is often used in data manipulation, which assigns values to a variable based on whether a condition is satisfied.

```{r}
mutate(farm,
       size2 = ifelse(size > 600, "big", "small"),   
       dummy_urban = ifelse(type == "urban", 1, 0)      # when testing for equality, use double ==
)
```

#### `summarize()`  

`summarize()` provides summary statistics, which always produce one single row if there are no grouping variables.

```{r}
summarize(farm, tot.return = sum(return))
summarize(farm, avg.return = mean(return))
summarize(farm,
          youngest = min(age),
          oldest = max(age),
          median = median(age),
          cor.size.return = cor(size, return))
```
:::callout-tip
It is often the case that we wish to know the summary statstics by a certain groups, e.g. average return by gender. Therefore, the use of `summarize()` is usually combined with `group_by()` and the pipe operator `%>%`.
:::

#### `group_by()` and `%>%`

##### `group_by()`

`group_by()` groups data by named variables, the use of `group_by()` itself does not change any variables, but only re-order the data, simlar to `arrange()`.

```{r}
group_by(farm, sex)
```


##### `%>%`

However, then main purpose of `group_by()` is to group your data to perform following operation. To achieve this, you will also need the pipe operator `%>%`. Functioning like pipes, `%>%` uses the output of one function as the input to the next function.

Suppose you wish to perform the steps below, based on the data **farm**:

1. calculate the return per acre, called "per.acre.return"
2. keep only the farms that are owned by farmers above 40 years old
3. create a new data frame only contains: names and age of the farmers, and the return per acre

```{r}
### without %>%
farm_wo_pipe1 <- mutate(farm, per.acre.return = return / size)
farm_wo_pipe2 <- filter(farm_wo_pipe1, age > 40)
farm_wo_pipe3 <- select(farm_wo_pipe2, c(name, age, per.acre.return))
farm_wo_pipe3

### with %>%

farm_w_pipe <- farm %>% mutate(per.acre.return = return / size) %>%
                        filter(age > 40) %>%
                        select(name, age, per.acre.return)
farm_w_pipe

```

##### Combining `group_by()` with `%>%`

Now, let's calculate summary statistics by groups, using `group_by()` with `%>%`.

```{r}
farm %>% group_by(sex) %>% summarize(num.farmer = n(),
                                     youngest = min(age),
                                     oldest = max(age),  
                                     
                                     tot.return = sum(return),
                                     avg.return = mean(return),
                                     avg.per.acre.return = mean(return/size),
                                     avg.size = mean(size))
```
 
#### Other Functions/Verbs

##### `slice()` and Its Variants
 
You can use `slice()` to select rows by position, or it variants

- `slice_head()` and `slice_tail()`: to select first/last rows
- `slice_min()` and `slice_max()`: to select rows with minimum/maximum values
- `slice_sample()`: to select random samples 

```{r}
farm
farm %>% slice(3)     # pick the observation in row 3
farm %>% slice(1:3)     # pick observations from row 1 through row 3
farm %>% slice_head(n = 3)      # pick first 3 rows, slice_tail would pick the last 3 rows
farm %>% slice_min(age, n = 3)      # pick 3 rows with the youngest ages, slice_max would pick 3 rows with the largest ages

farm %>% slice_sample(n = 3)      # randomly pick 3 observations 
farm %>% slice_sample(prop = 0.5)     # randomly pick 50% of the data 
```

##### `count()` 

`count()` counts the number of observations for each category.

```{r}
count(farm)     # count the number of observations
count(farm, type)     # count observations per type of farm
count(farm, type, order = TRUE)     # add argument for order
count(farm, type, wt = return, sort = TRUE)     # add argument for weight
```

### Export and Import Data

This section introduces functions in base R allowing you to export your data for later usage or import your saved data. To learn more about import/export data, check out this [link](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/read.table). 

#### RData Format

```{r}
#| eval: FALSE
### export 
save(farm, file = "farm.Rdata")     # save to the current working directory
# specify the file path if you wish to save to a different location

### import
load("farm.Rdata")      # load from the current working directory
# specify the file path if your file is loaded 
```

#### csv Format

```{r}
#| eval: FALSE
### export
write.csv(farm, "farm.csv")

### import
farm <- read.csv("farm.csv")
```

#### Other Format

If you are working with SPSS, Stata or SAS data files, *haven* is a good package for importing and exporting files of those formats.  

:::callout-tip
A handy trick to import data interactively, without the need of specifying a path, try `read.csv(file.choose())`.
:::

### Useful Resources

#### dplyr Cheat Sheet
 
[Click here for more information](https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf) 

```{r}
#| echo: false
#| fig-cap: ""
knitr::include_graphics("D:/Dropbox/Teaching/AREC513/Fall2025/materials/graph/lab2/cheatsheet1.png")
knitr::include_graphics("D:/Dropbox/Teaching/AREC513/Fall2025/materials/graph/lab2/cheatsheet2.png")
```

#### R for Data Science

See Chapter 5 of [R for Data Science, by Wickham, H., & Grolemund, G.](https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf)

### Exercise
 
Continue from the dataset "farm" used in this section, work through the exercises below.

1. Generate a new variable called **size3** that meets the following criterion: 

- size3 = “small” if size <= 200
- size3 = “median” if 200 < size <= 600
- size3 = “big” if size > 600

Finally, convert **size3** to a factor variable. 

 
2. Generate the following summary statistics, for each type of the farms:

1. the sum of all returns, called **tot.return**
2. the average returns, called **avg.return**

Finally, rearrange the data based on the value of avg.return, in the descending order.
 
## Data Visualization using ggplot

```{r}
library(tidyverse) 
library(gapminder) # for additional data
library(patchwork) # optional, used to show graphs side by side
```

### Introduction to ggplot2

`ggplot2` is a plotting package that provides powerful commands to create graphs from data in a data frame. It offers a more programmatic interface for specifying which variables to plot, how they are displayed, and general visual properties. Therefore, we only need minimal changes if the underlying data change or if we decide to switch from a bar plot to a scatterplot. This helps in creating publication-quality plots with minimal adjustments and tweaking. [Reference](https://datacarpentry.github.io/R-ecology-lesson/visualizing-ggplot.html). 

- The "gg" here refers to "grammar of graphics".
- Every graph consists of one or more geometric layers.

For demonstration, we will use the built-in data set, `mpg`, first.

```{r}
data(mpg)     
head(mpg)     
```

### Layered Grammar of Graphics
 
For our illustration of functions in *ggplot2* in Lab 2, the layered grammar of graphics follows the template below. We will go through them step by step in the following sections.
```{r}
#| error: TRUE 
#| eval: FALSE
 ggplot(data = <DATA>) + 
     <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>)) +
     <FACET_FUNCTION> +
     <SCALE_FUNCTION> +
     <LABS_FUNCTION> +
     <THEME_FUNCTION>
```

### Layers in ggplot2

#### Geometric Layers

##### Commonly Used `geom` Functions

Below is a list of commonly used `geom` functions, we will explore all of them in the rest of this section:

1. `geom_point()`: creates scatterplots

2. `geom_line()`: creates line plots

3. `geom_bar()`: creates bar charts of counts

4. `geom_col()`: creates bar charts of values

5. `geom_boxplot()`: shows distributions and outliers with boxplots

6. `geom_smooth()`: adds a fitted trend line

7. `geom_jitter()`: aids the visualization of points by adding "jitter" to their positions

```{r}
# create a scatter plot  
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy)) 

# add another layer
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy), color = "red") +      # you can also request a specific color
    geom_smooth(mapping = aes(x = displ, y = hwy))
```

The `geom_xxx()` functions can inherit both the data and aesthetic mappings from the top level of the plot, due to the argument `inherit.aes = TRUE` by default (as specified in the R Documentation). As a result, you can simplify your code as follows:

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
    geom_point(color = "red") +
    geom_smooth()
```

##### Aesthetic Mapping

Recall our previous code, 

```{r}
#| echo: FALSE
#| fig-cap: ""
#| out.width: "70%"
knitr::include_graphics("D:/Dropbox/Teaching/AREC513/Fall2025/materials/graph/lab2/ggplot_aes.png") 
``` 


Aesthetics in `geom_xxx()` statement can be specified in two ways:

(1) **inside** the `aes()` function, which maps **variables** to aesthetics to represent or enhance visual features.

(1) **outside** the `aes()` function, which takes **fixed values**. This step is usually optional.

`geom_xxx(aes(ARGUMENTS = variable, ...), ARGUMENTS = fixed values)`. Some commonly used aesthetics are:

- `x`, `y`: define the variables for the x- and y-axes (must be inside `aes()`).

- `color`: defines the color of lines and strokes.

- `fill`: defines the color inside areas of geoms.

- `shape`: defines the symbols of points.

- `size`: defines the size of points.

- `alpha`: defines the opacity of geoms.

The examples below show the difference between mapping variables and mapping fixed values to aesthetics.

```{r}
#| warning: false
#| fig-width: 12
#| fig-height: 6
p1 <- ggplot(data = mpg) +
        geom_point(mapping = aes(x = displ, y = hwy, color = drv)) # map variable to color 
  
p2 <- ggplot(data = mpg) +
        geom_point(mapping = aes(x = displ, y = hwy), color = "red") # color now is mapped by a fixed value 

p1 + p2 # enabled by "patchwork"              
```


```{r}
#| warning: false
#| fig-width: 12
#| fig-height: 6
p3 <- ggplot(data = mpg) +
        geom_point(mapping = aes(x = displ, y = hwy, shape = drv))  # map variable to shape 
  
p4 <- ggplot(data = mpg) +
        geom_point(mapping = aes(x = displ, y = hwy), shape = 2)  # shape now is mapped by a fixed value 

p3 + p4               
```

```{r}
#| warning: false
#| fig-width: 12
#| fig-height: 6
p5 <- ggplot(data = mpg) +
        geom_point(mapping = aes(x = displ, y = hwy, size = drv))  # map variable to size 
  
p6 <- ggplot(data = mpg) +
        geom_point(mapping = aes(x = displ, y = hwy), size = 3)  # size now is mapped by a fixed value 

p5 + p6               
```

```{r}
#| warning: false
#| fig-width: 12
#| fig-height: 6
p7 <- ggplot(data = mpg) +
        geom_point(mapping = aes(x = displ, y = hwy, alpha = drv))  # map variable to alpha 
  
p8 <- ggplot(data = mpg) +
        geom_point(mapping = aes(x = displ, y = hwy), alpha = 0.1)  # alpha now is mapped by a fixed value 

p7 + p8               
```

```{r}
#| warning: false
#| fig-width: 12
#| fig-height: 6
p9 <- ggplot(data = mpg) +
        geom_bar(mapping = aes(x = class, fill = drv))  # map variable class to fill
  
p10 <- ggplot(data = mpg) +
       geom_bar(mapping = aes(x = class), fill = "red")  # fill now is mapped by a fixed value 

p9 + p10               
```

##### Commonly Used Fixed Values

As shown above, **fixed values** mapped to aesthetics are usually numbers or strings. Below are some commonly used fixed values for `geom` functions:

- `color` and `fill`: see [R color cheatsheet](https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf).
 
- `linetype` and `shape`: see [Cookbook for R](http://www.cookbook-r.com/Graphs/Shapes_and_line_types/) 

- `size`: takes numeric values; larger values correspond to larger sizes.

- `alpha`: takes values between 0 and 1; larger values correspond to less transparency.

- Some extra examples are shown below

```{r}
#| message: false
#| warning: false
#| fig-width: 12
#| fig-height: 6

mpg_class_year_hwy <- mpg %>% group_by(class, year) %>% summarize(mean_hwy = mean(hwy))

p11 <- ggplot(data = mpg_class_year_hwy, aes(year, mean_hwy, color = class)) +
        geom_line(size = 2, linetype = "dotdash")   
  
p12 <- ggplot(data = mpg_class_year_hwy, aes(year, mean_hwy, color = class)) +
        geom_line(size = 2, linetype = 4) +
        geom_point(size = 4, shape = 15)

p11 + p12               
```

```{r}
#| message: false
#| warning: false
#| fig-width: 12
#| fig-height: 6

mpg_class_hwy <- mpg %>% group_by(class) %>% summarize(mean_hwy = mean(hwy))

p13 <- ggplot(data = mpg_class_hwy, mapping = aes(x = class, y = mean_hwy)) +
        geom_col(fill = "lightblue1")  
  
p14 <- ggplot(data = mpg_class_hwy, mapping = aes(x = class, y = mean_hwy)) +
        geom_col(fill = "lightblue3")   

p13 + p14               
```
 
```{r}
#| warning: false
#| fig-width: 12
#| fig-height: 6
 
p15 <- ggplot(data = mpg, aes(x = drv, y = hwy, color = drv)) +
        geom_boxplot() 
  
p16 <- ggplot(data = mpg, aes(x = drv, y = hwy, color = drv)) +
        geom_boxplot() + 
        geom_jitter(width = 0.333) 

p15 + p16               
```
  
#### Facets 

`facet_wrap()`: partitions a plot into a matrix of panels, typically based on the values of **one faceting variable**. Each panel shows a different subset of the data.

`facet_grid()`: partitions a plot into a matrix of panels, based on the combination of **two faceting variables**.

Following the previous practice, let us create a line plot to show the trend of average fuel efficiency for each manufacturer.  
 
```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8

mpg_mfr_year_hwy <- mpg %>% group_by(manufacturer, year) %>% summarize(mean_hwy = mean(hwy))
 
p17 <- ggplot(data = mpg_mfr_year_hwy, aes(year, mean_hwy, color = manufacturer)) +
        geom_line(size = 2)
  
p18 <- ggplot(data = mpg_mfr_year_hwy, aes(year, mean_hwy, color = manufacturer)) +
        geom_line(size = 2) + 
        facet_wrap(~ manufacturer) 

p17 + p18               
```

As you can see in "p17", the graph is not effective in showing the trend in fuel efficiency across time for some of the manufacturers. "p18" partitions the plot into subplots for each individual manufacturer. Since all panels share the same scale for "mean_hwy", the graph is still not effective. To improve, you can add `scales = "free"` to allow different scales for subplots. 
 
```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8
 
p19 <- ggplot(data = mpg_mfr_year_hwy, aes(year, mean_hwy, color = manufacturer)) +
        geom_line(size = 2) + 
        facet_wrap(~ manufacturer, scales = "free")  

p18 + p19               
```

Now, let's see how `facet_wrap()` differs from `facet_grid()`, starting with graph(s) showing "hwy" vs. "displ".

```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8

p20 <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
        geom_point() +
        geom_smooth()

p21 <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
        geom_point() +
        geom_smooth() +
        facet_wrap(~drv)

p20 + p21
```

As shown below, `facet_wrap()` shows the relationship for each value of **"drv"**, while `facet_grid()` shows the relationship for each combinations of the values of **"drv"** and **fl**.

```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8

p22 <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
        geom_point() +
        geom_smooth() +
        facet_wrap(~drv, nrow = 3, strip.position = "right") # adding nrow and strip.position for better visualization

p23 <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
        geom_point() +
        geom_smooth() +
        facet_grid(drv ~ fl)

p22 + p23
```
  
#### Scales

##### Scales of Axes

This section explores some common functions that scale the axes of your graph. 

- When mapping **discrete variables**: the default functions are `scale_x_discrete()` for the x-axis, and `scale_y_discrete()` for the y-axis.

- When mapping **continuous variables**: the default functions are `scale_x_continuous()` for the x-axis, and `scale_y_continuous()` for the y-axis.

  - Built-in functions like `scale_x_log10()`, `scale_x_sqrt()`, and `scale_x_reverse()` provide easy access to common transformations: base-10 logarithm, square root, and reversed order.

For this section, let's use a new dataset from the package *gapminder*. See how arguments `limits` controls the min/max of the axes, and `breaks` displays ticks only at specified values.

```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8
 
glimpse(gapminder)

base_plot <- ggplot(gapminder, aes(x = gdpPercap, y = lifeExp, color = continent)) +
              geom_point() 

scale_x_y <- base_plot + 
              scale_x_continuous(limits = c(0, 50000), breaks = c(10000, 25000, 50000)) +
              scale_y_continuous(limits = c(20, 70), breaks = c(30, 50, 70))

base_plot + scale_x_y
```


```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8
 
built_in_log10 <- base_plot + scale_x_log10()

manual_log10 <- ggplot(gapminder, aes(x = log10(gdpPercap), y = lifeExp, color = continent)) +
                  geom_point() 

built_in_log10 + manual_log10
```
```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8
 
base_plot_reverse <- base_plot + scale_x_reverse() + scale_y_reverse()
 
base_plot + base_plot_reverse
```

##### Scales of Colors

Recall you can set the color of your graphs using the aesthetics `color` and/or `fill`. 

```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8

# building a simple dataframe
mydata <- data.frame(x = c("a", "b", "c", "d"), y = c(1, 2, 3, 4))
mydata

bar_color <- ggplot(mydata, aes(x = x, y = y, color = x)) + geom_col()
bar_fill  <- ggplot(mydata, aes(x = x, y = y, fill = x))  + geom_col()

bar_color + bar_fill

bar_color_scale <- bar_color + scale_color_discrete()  # since x is discrete now
bar_fill_scale  <- bar_fill  + scale_fill_discrete()  

bar_color_scale + bar_fill_scale # no changes since we are using defaults 

```
To assign different colors to different values of "x", we can utilize the function `scale_fill_brewer()`, which uses the color palettes from the package *RColorBrewer* without the need of installing and loading the package. To see all the colors, check [this link](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html) or type `RColorBrewer::display.brewer.all()`.

```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8

 
bar_fill_brewer_1 <- bar_fill + scale_fill_brewer(palette = "OrRd")

bar_fill_brewer_2 <- bar_fill + scale_fill_brewer(palette = "BrBg")

bar_fill_brewer_1 + bar_fill_brewer_2

```

#### Labs and Themes

To modify elements of a plot other than the data, such as axes, legend, or title, use `labs()` and `theme()`. See how the example below applies changes to the graph "bar_fill" on axis, legend and plot title.

```{r}
#| message: false
#| warning: false
#| fig-width: 18
#| fig-height: 8
 
bar_fill_mod <- bar_fill + labs(x = "Letters", y = "Numbers", fill = "Legend", title = "bar_fill Modified") +
                                theme(
                                  axis.title = element_text(size = 24, face = "bold"),
                                  axis.text = element_text(size = 20),
                                  axis.text.x = element_text(angle = 45),
                                  
                                  legend.title = element_text(size = 24, face = "bold"),
                                  legend.text = element_text(size = 20),
                                  legend.position = "bottom",
                                  
                                  title = element_text(size = 30, face = "bold")
                                )
        

bar_fill + bar_fill_mod

```

#### Built-in Themes

There are a number of built-in themes come with *ggplot2* that you can use without the need to specify every element of your graphs. The default theme of *ggplot2* is `theme_grey()`. Let's see some examples on our base plot below.
```{r}
#| message: false
#| warning: false  
 
base_theme <- ggplot(data = mpg, aes(x = displ, y = hwy)) +
                geom_point(color = "red") +
                geom_smooth() +
                labs(x = "Engine Displacement", y = "Highway Mileage", title = "Fuel Efficiency") 
base_theme  

```
```{r}
#| message: false
#| warning: false 
#| fig-width: 18
#| fig-height: 8
 
base_theme_default <- base_theme + theme_grey() + labs(title = "theme_grey()")
        
base_theme1 <- base_theme + theme_bw() + labs(title = "theme_bw()")

base_theme2 <- base_theme + theme_classic() + labs(title = "theme_classic()")

base_theme3 <- base_theme + theme_minimal() + labs(title = "theme_minimal()")
        
base_theme4 <- base_theme + theme_linedraw() + labs(title = "theme_linedraw()")

base_theme5 <- base_theme + theme_light() + labs(title = "theme_light()")

base_theme6 <- base_theme + theme_dark() + labs(title = "theme_dark()")

base_theme7 <- base_theme + theme_void() + labs(title = "theme_void()")

(base_theme_default + base_theme1 + base_theme2 + base_theme3 +
 base_theme4 + base_theme5 + base_theme6 + base_theme7) + 
  plot_layout(ncol = 4, nrow = 2)

```

Extra themes and scales can be acquired by installing package *ggthemes*. To see the complete list, visit [this webiste](https://jrnold.github.io/ggthemes/?utm_source=chatgpt.com).

### Annotating and Saving Plots

Sometimes, you may wish to add text in your graphs to highlight certain elements. Take "base_plot" in Section [2.3.3](#scales) for example, say you wish to highlight countries with high GDP per capita (above $50,000) but low life expectancy (below 70 years old).

```{r}
#| message: false
#| warning: false 
#| fig-width: 18
#| fig-height: 8

h_country <- gapminder %>% filter(gdpPercap > 50000 & lifeExp < 70) # create the data that's to be highlighted in the graph

base_plot_text <- base_plot + 
                    geom_text(data = h_country, aes(label = country), size = 4, vjust = 1.5, show.legend = FALSE) + 
                    geom_text(data = h_country, aes(label = year), size = 4, vjust = 2.75, show.legend = FALSE) 

base_plot + base_plot_text

```

To save a created plot, you can use the function `ggsave()` as below.

```{r}
#| eval: FALSE

ggsave("gdp_lifeExp.png", plot = base_plot_text, width = 10, height = 7)  # save to your current working directory

# you can save ggplot as one of "eps", "ps", "tex", "pdf", "jpeg", "tiff", "png", "bmp", "svg" or "wmf" 
# you can also use different units = c("in", "cm", "mm", "px"),  
# ggsave("myplot.pdf", width = 20, height = 20, units = "cm")

```

### Useful resources

#### ggplot2 Cheat Sheet
 
[Click here for more information](https://rstudio.github.io/cheatsheets/data-visualization.pdf) 

```{r}
#| echo: false
#| fig-cap: ""
knitr::include_graphics("D:/Dropbox/Teaching/AREC513/Fall2025/materials/graph/lab2/cheatsheet3.png")
knitr::include_graphics("D:/Dropbox/Teaching/AREC513/Fall2025/materials/graph/lab2/cheatsheet4.png")
```

#### R for Data Science

See Chapter 3 and 28 of [R for Data Science, by Wickham, H., & Grolemund, G.](https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf)

#### ggplot2: Elegant Graphics for Data Analysis

See the third edition of [ggplot2: Elegant Graphics for Data Analysis, by Hadley Wickham, Danielle Navarro, and Thomas Lin Pedersen](https://ggplot2-book.org/).

### Exercise